import java.math.BigDecimal;
import java.util.Stack;

/**
 * Highly divisible triangular number
 *
 * Problem 12
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 * The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 *
 * Result:
 * I had to run the program a few times (I set it initially to find exactly
 * 500 divisors so it ran for a while.)
 * However still got the right answer.
 * Answer: 76576500
 * I did i through brute force but I got it done. Took about 30 minutes to find
 * the answer.
 */
public class Problem12 {

    /**
     * Main that starts the program and executes helper methods.
     * @param args arguments to be passed in.
     */
    public static void main(String[] args) {
        System.out.println(triangleNumber());
    }

    /**
     * This method goes and creates triangle num using a loop.
     * Then gets the number of factors from factorSize(). Using that information
     * the program then determines if its over or equal to 500.
     * @return a double representing the triangle number.
     */
    private static double triangleNumber() {
        boolean condition = false;
        double triangle = 0;
        double maxFactors = 0;
        double j  = 1;
        while (!condition) {
            for (int i = 1; i <= j; i++) {
                triangle = triangle + i;

            }

            double triangleFactors = factorSize(triangle);
            if (triangleFactors > maxFactors) {
                System.out.println("New Max! " + triangleFactors + " " +
                        triangle);
                maxFactors = triangleFactors;
            }


            if (triangleFactors >= 500) {
                System.out.println(j);
                System.out.println(BigDecimal.valueOf(triangle));
                return triangle;
            }
            j++;
            triangle = 0;
        }
        return -1;
    }

    /**
     * factorSize takes a value and finds the factors within in. Uses brute
     * force to iterate through each value and find the number of factors
     * @param toBeFact number inputted.
     * @return double representing the number of factors.
     */
    private static double factorSize
            (Double toBeFact) {
        Stack<Double> factors = new Stack<>();
        Stack<Double> temp = new Stack<>();
        for (double i = 1; i <= toBeFact; i++) {
            if (i == 1) {
                Double one = i;
                factors.add(i);
                continue;
            }
            if (toBeFact % i == 0) {
                if (i < 0) {
                    return factors.size();
                }
                Double tempD = i;
                factors.add(tempD);
            }

        }
        return factors.size();
    }
}
